#include "Tools.h"

typedef struct {
    mpz_class p; ///< The prime order of the finite field.
    ECP P1;      ///< The generator of the elliptic curve group.
    ECP PK;      ///< The system's public key (generated using coefficients).
} Params;

typedef struct {
    int i; ///< User's index.
    mpz_class si; ///< User's secret share (computed from polynomial coefficients).
    ECP Yi;       ///< User's public key component (derived from `si`).
    std::vector<mpz_class> di; ///< Random scalar values used in preprocessing (part of (Di, Ei)).
    std::vector<mpz_class> ei; ///< Random scalar values used in preprocessing (part of (Di, Ei)).
    std::vector<ECP> Di; ///< Preprocessed elliptic curve points (Di = di * P1).
    std::vector<ECP> Ei; ///< Preprocessed elliptic curve points (Ei = ei * P1).
} User;

typedef struct {
    ECP Di; ///< The Di elliptic curve point (di * P1).
    ECP Ei; ///< The Ei elliptic curve point (ei * P1).
} PairDE;

typedef struct {
    ECP R; ///< The elliptic curve point R in the signature.
    mpz_class z; ///< The scalar z in the signature (aggregated).
} Sigma;


/**
 * @brief Initializes the coefficients for the polynomial.
 *
 * @param coefficients Reference to a vector that will hold the polynomial coefficients.
 */
void InitializeCoefficients(std::vector<mpz_class> &coefficients);

/**
 * @brief Sets up system parameters, including group generator, curve order, and public key.
 *
 * @param coefficients Reference to a vector that will hold the polynomial coefficients.
 * @return Params Struct containing the system parameters.
 */
Params Setup(std::vector<mpz_class> &coefficients);

/**
 * @brief Generates a user's private key and public key component based on their index.
 *
 * @param params Reference to the system parameters.
 * @param index The index of the user.
 * @param coefficients Polynomial coefficients for generating the user's private key.
 * @return User Struct containing the user's key information.
 */
User KeyGen(const Params &params, int index, const std::vector<mpz_class> &coefficients);

/**
 * @brief Preprocesses user-specific data, including generating pairs (di, Di) and (ei, Ei) for each user.
 *
 * @param params Reference to the system parameters.
 * @param users Reference to a vector of users whose data will be preprocessed.
 * @return std::vector<std::vector<PairDE>> A 2D vector containing preprocessed data for all users.
 */
std::vector<std::vector<PairDE>> PreProcess(Params &params, std::vector<User> &users);

/**
 * @brief Selects a subset of users to participate in the signing process.
 *
 * @param users Reference to a vector of all users.
 * @return std::vector<PairDE> A vector of selected signers' data pairs (Di, Ei).
 */
std::vector<PairDE> SelectSigner(const std::vector<User> &users);

/**
 * @brief Computes a hash (H1) based on the index, message, and preprocessed data of selected signers.
 *
 * @param index The index of the signer.
 * @param message The message to be signed.
 * @param B Reference to the preprocessed data of selected signers.
 * @return mpz_class The computed hash value.
 */
mpz_class H1(int index, mpz_class message, std::vector<PairDE> &B);

/**
 * @brief Computes a hash (H2) based on an elliptic curve point R, public key Y, and the message.
 *
 * @param R Elliptic curve point representing part of the signature.
 * @param Y The system's public key.
 * @param message The message to be signed.
 * @return mpz_class The computed hash value.
 */
mpz_class H2(ECP R, ECP Y, mpz_class message);

/**
 * @brief Computes the value of the Lagrange basis polynomial at zero for a given index.
 *
 * @param x Reference to a vector of indices representing the x-coordinates of points.
 * @param index The index of the Lagrange basis polynomial to evaluate.
 * @param modulus The modulus of the finite field.
 * @return mpz_class The computed value of the Lagrange basis polynomial at zero, modulo `modulus`.
 */
mpz_class ComputeLagrangeCoefficient(const std::vector<int> &x, int index, mpz_class modulus);

/**
 * @brief Computes the elliptic curve point R based on the selected signers' data and the message.
 *
 * @param B Reference to the preprocessed data of selected signers.
 * @param message The message to be signed.
 * @return ECP The computed elliptic curve point R.
 */
ECP ComputeR(std::vector<PairDE> &B, mpz_class message);

/**
 * @brief Generates a partial signature for a user using their private data and the system parameters.
 *
 * @param user Reference to the user struct containing private key information.
 * @param params Reference to the system parameters.
 * @param message The message to be signed.
 * @param B Reference to the preprocessed data of selected signers.
 * @return mpz_class The partial signature generated by the user.
 */
mpz_class Sign(const User &user, const Params &params, mpz_class message, std::vector<PairDE> &B);

/**
 * @brief Aggregates multiple partial signatures into a single signature.
 *
 * @param zValues Reference to a vector of partial signatures.
 * @param params Reference to the system parameters.
 * @param message The message being signed.
 * @param B Reference to the preprocessed data of selected signers.
 * @param users Reference to a vector of all users involved in signing.
 * @return Sigma The aggregated signature.
 */
Sigma Aggregate(const std::vector<mpz_class> &zValues, const Params &params, mpz_class message, std::vector<PairDE> &B,
                const std::vector<User> &users);

/**
 * @brief Verifies the aggregated signature against the message and public key.
 *
 * @param sigma Reference to the aggregated signature.
 * @param params Reference to the system parameters.
 * @param message The message being verified.
 * @return true If the signature is valid.
 * @return false If the signature is invalid.
 */
bool Verify(Sigma &sigma, Params &params, mpz_class message);


